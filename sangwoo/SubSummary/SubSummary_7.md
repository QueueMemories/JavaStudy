## 상속

---

객체 지향 프로그래밍에서는 부모 클래스의 멤버를 자식 클래스에게 물려줄 수 있다. 프로그램에서 부모 클래스를 상위 클래스라고 부르고, 자식 클래스를 하위 클래스 or 파싱 클래스라고 부른다.

<br>

상속의 장점은 이미 잘 개발되어 있는 클래스를 재사용해서 새로운 클래스를 만들기 때문에, 중복되는 코드를 줄일 수 있다는 점이다. 또한, 부모 클래스의 수정으로 모든 자식 클래스들도 수정되는 효과를 가져오기 때문에, 유지 보수 시간을 최소화할 수도 있다.

<br>

### 클래스 상속

---

프로그램에서는 자식 클래스를 선언할 때, 어떤 부모 클래스를 상속받을 것인지 결정하고, 선택된 부모 클래스는 다음과 같이 extends 뒤에 기술한다.

```java
class 자식클래스 extends 부모클래스 {
	// 필드
	// 생성자
	// 메서드
}
```

<br>

**상속의 특징**

1. 여러 개의 부모 클래스를 상속할 수 없다. 즉, 다중 상속이 불가능하다.
2. 부모 클래스에서 private 접근 제한을 갖는 필드와 메서드는 상속 대상에서 제외된다. 그리고 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메서드도 상속 대상에서 제외된다.

<br>

### 부모 생성자 호출

---

자바에서는 자식 객체를 생성하면, 부모 객체가 먼저 생성되고 그 다음에 자식 객체가 생성된다.

<br>

이때, 우리는 모든 객체는 클래스의 생성자를 호출해야 생성된다고 알고 있다. 그렇다면 부모 객체는 언제 생성자를 통해 생성된걸까 ? 이 비밀은 자식 생성자에 숨어 있다. 부모 생성자는 자식 생성자의 맨 첫 줄에서 호출된다.

<br>

만일, CellPhone이라는 클래스를 상속받은 DmbCellPhone 클래스의 생성자가 명시적으로 선언되지 않았다면, 컴파일러는 아래와 같은 기본 생성자를 생성한다.

```java
public DmbCellPhone() {
	super();
}
```

첫 줄에 super(); 가 추가 되었다. 이는 부모의 기본 생성자를 호출한다. 만일 우리가 직접 자식 생성자를 선언하고, 명시적으로 부모 생성자를 호출하고 싶다면, 자식 생성자의 첫번째 줄에, super를 통해 필요한 매개변수를 넘기면 된다. 이렇게 하지 않고, 부모 생성자를 명시하지 않아 super(); 가 자동으로 추가 되었다면 부모 클래스에는 반드시 기본 생성자가 존재해야 한다.

<br>

### 메서드 재정의 (Overriding)

---

이는 부모 클래스의 모든 메서드가 자식 클래스에 맞게 설계되어 있지 않아, 자식 클래스가 부모 클래스의 특정 메서드를 재편성 해야할 때 사용된다. 

<br>

**메서드 재정의 방법**

- 부모의 메서드와 동일한 시그니처(리턴 타입, 메서드 이름, 매개 변수 목록)을 가져야 한다.
- 접근 제한을 더 강하게 재정의할 수 없다( 더 약하게는 가능하다 ).
- 새로운 예외 (Exception)을 throws 할 수 없다.

<br>

**@Override** - 오버라이딩에 쓰이는 어노테이션으로, 컴파일러가 정확히 재정의 되었는지 확인해준다.

<br>

**부모 메서드 생성**

자식 클래스에서 부모 클래스의 메서드를 재정의하게 되면, 부모 클래스의 메서드는 숨겨지고 재정의된 자식 메서드만 사용된다. 

<br>

만약에 자식 클래스 내부에서 직접 재정의된 부모 클래스의 메서드를 호출해야 되는 상황이 발생한다면 ?

<br>

```java
super.부모메서드();
```

위 코드를 통해 부모 클래스 내부의 메서드에 직접 접근이 가능하다. (매개변수는 올바르게 작성해야 한다.)

<br>

## final 클래스와 final 메서드

---

클래스와 메서드를 선언할 때, final 키워드가 지정되면 상속과 관련이 있다.

<br>

**상속할 수 없는 final 클래스**

클래스를 선언할 때, final 키워드를 class 앞에 붙이면 이 클래스는 최종적인 클래스이므로, 상속할 수 없는 클래스가 된다. 즉, final 클래스는 부모 클래스가 될 수 없어 자식 클래스를 만들 수 없다.

<br>

**재정의할 수 없는 final 메서드**

메서드를 선언할 때, final 키워드를 붙이면 이 메서드는 최종적인 메서드이므로 재정의할 수 없는 메서드가 된다. 즉, 부모 클래스를 상속해서 선언할 때, 부모 클래스에 선언된 final 메서드는 자식 클래스에서 재정의할 수 없다.

<br>

## protected 접근 제한자

---

접근 제한자는 public , protected, default, private와 같이 네 가지 종류가 존재한다. 그 중 상속과 관련이 있는 protected 접근 제한자에 대해 더 알아본다.

<br>

protected는 public과 default 접근 제한의 중간쯤에 해당한다. 같은 패키지에서는 default와 같이 접근 제한이 없지만, 다른 패키지에서는 자식 클래스만 접근을 허용하기 때문이다.

<br>

**protected**가 쓰일 수 있는 곳은 **필드, 생성자, 메서드**이다.

```java
package pack1;

public class A {
    
    // field
	protected String field;

    // constructor
	protected A() {
	}

    // method
	protected void method() {
	}
}
```

위 A 클래스를 통해 protect에 대해 알아보자.

<br>

1. B class
    
    ```java
    package pack1;
    
    public class B {
    
    	public void method() {
    		A a = new A();
    		a.field = "value";
    		a.method();
    		// 접근 가능
    		// 같은 패키지이기 때문이다.
    	}
    }
    ```

<br>
    
2. C class
    
    ```java
    package pack2;
    import pack1.A;
    
    public class C {
    
    	public void method() {
    		A a = new A();
    		a.field = "value";
    		a.method();
    		// 접근 불가능.
    		// 다른 패키지에 있기 때문이다.
    	}
    }
    ```

<br>
    
3. D class
    
    ```java
    package pack2;
    import pack1.A;
    
    public class D extends A {
    
    	public D {
    		super();
    		this.field = "value";
    		this.method();
    		// 접근 가능
    		// D 클래스는 A 클래스의 자식이기 때문이다.
    		// new 연산자를 통한 생성자 접근은 불가하고,
    		// super()를 통해 A 생성자를 호출하여 접근이 가능하다.
    	}
    }
    ```