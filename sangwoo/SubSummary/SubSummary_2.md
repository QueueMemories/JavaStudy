**컴퓨터 메모리(RAM)** 는 값을 저장할 수 있는 수많은 번지(주소)들로 구성되어 있다. 메모리에 어디에 저장하고, 어떤 방식으로 저장할지 정해놓은 규칙을 변수라고 한다.

**변수 (variable)** - 값을 저장할 수 있는 메모리의 특정 번지에 붙이는 이름. JVM은 변수를 메모리의 어디에 저장하고, 어떤 방식으로 저장할지 정하는 역할을 한다.

**예약어** - 해당 프로그래밍 언어에서 의미를 갖고 사용되고 있는 단어.

**메서드** - 어떤 일을 처리하는 실행문들을 모아놓은 블록.

<br>

자바에서는 변수에 값이 저장되지 않으면 변수가 생성되지 않는다. 변수에 최초로 값이 저장될 때, 변수가 생성되고 이를 **변수 초기화**, 이때 사용된 값을 **초기값**이라고 한다.

<br>

자바의 모든 변수는 중괄호 {} 블록(class, interface, enum, method, if, for, while, … ) 내에서 선언되고 사용된다. 메소드 블록 내에서 선언된 변수는 **로컬 변수(local variable)**이라고 부른다. 이 스코프는 메소드 블록 내부에서 사용되고 메소드 실행이 끝나면 메모리에서 사라진다. 즉, 변수는 자신이 속한 블록내에서만 사용 가능.

<br>

<h2>기본 타입 (primitive type)</h2>

---

정수, 실수, 논리값을 저장할 수 있는 기본 타입을 제공. 총 8개

<br>

<h3>정수 타입 - byte, char, short, int, long</h3>

- byte ( 1byte == 8bit )
- short ( 2byte == 16bit )
- char ( 2byte == 16bit ), 음수 불가능 (유니코드)
- int ( 4byte == 32bit )
- long ( 8byte == 64bit )

<br>

**정수 리터럴(literal)** - 값 자체를 뜻함. 2진수 ~ 16진수로 표현할 수 있다.

<br>

long 타입을 이용하기 위해서는 숫자 뒤에 L을 붙여야 한다. long 타입을 이용하더라도 정수 리터럴이 int 타입의 허용 범위 이내라면 L을 붙이지 않아도 된다.

<br>

char 타입은 ‘’로 감싼다. 이를 문자 리터럴이라고 하며, 이는 유니코드(Unicode)로 변환되어 저장된다.

<br>

문자 리터럴을 변수에 저장할 때, char 타입은 유니코드로 매핑되어 들어가고 int 타입에는 유니코드 자체가 출력됨. (결국 char 타입도 정수(숫자) 이기 때문에 본래 유니코드에 해당하는 숫자가 들어감)

<br>

문자열 내부에 들어가는 역슬래시(\)는 **이스케이프 (escape) 문자**이다. 이를 이용해 특정 문자를 문자열 내부에 포함시킬 수 있다.

<br>
<blockquote>
\t - 탭만큼 띄움, \n - 줄바꿈, \r - 캐리지리턴, \u16진수 - 16진수 유니코드에 해당하는 문자 출력.
</blockquote>
<br>

<h3>실수 타입 - float, double</h3>

- float ( 4byte == 32bit ) - 소수점 이하 7자리
- double ( 8byte == 64bit ) - 소수점 이하 15자리

<br>

자바에서 실수 리터럴은 기본적으로 double 타입으로 해석하기에, float 타입에 실수 리터럴을 저장하면 오류가 발생. 이를 막기 위해서 F or f 를 붙여야 한다.

<br>

<h3>논리 타입 - boolean</h3>


- true
- false

<br><br>

<h2>타입 변환</h2>

---

**자동 타입 변환 ( promotion )** - 허용 범위가 작은 타입이 허용 범위가 큰 타입으로 저장될 때 발생.

<br>

char의 자동 타입 변환은 유니코드 값이 int 타입에 저장된다. 

예외 ) byte → char 불가능 (byte는 음수를 포함하기 때문)

<br>

**강제 타입 변환 ( casting )** - 큰 허용 범위 타입을 작은 허용 범위 타입으로 강제로 나눠서 저장하는 것.

<br>

실수 타입(float, double)은 정수 타입(byte, short,int, long) 으로 자동 변환되지 않기 때문에 강제 타입 변환을 사용해야 한다. (정수부만 저장됨)

<br>

### 정수 연산에서 자동 타입 변환

1. int 타입 보다 작은 byte, short 타입의 변수가 피연산자로 사용되면 자동으로 int 타입으로 자동 타입 변환되어 연산을 수행. (따라서 int 타입 변수에 연산값을 넣어야 함)
2. int 타입 보다 허용 범위가 큰 long 타입이 피연산자로 사용되면 다른 피 연산자는 무조건 long 타입으로 변환 후, 연산이 실행됨. (따라서 long 타입 변수에 연산값을 넣어야 함)

<br>

### 실수 연산에서 자동 타입 변환

1. 연산 중, 피연산자 중 하나라도 double이라면 모두 double 타입으로 자동 변환 되어 연산을 수행한다. (따라서 double 타입 변수에 연산값을 넣어야 함)
2. 정수와 실수를 연산할 때도, 더 큰 타입의 피연산자로 자동 변환되어 연산이 수행된다.

<br>

```java
int x = 1; int y = 2;
double result = x / y;
// result의 값은 0.0 , int 타입 연산 후, double 타입에 대입하기 때문

// 이를 보완하기 위해서는 ( x ) or ( y ) or ( x와 y 둘다 ) 
// 위 셋 중의 하나의 케이스를 double 타입으로 (double) 캐스트 해주면 된다.
```


+연산에서 문자열이 있다면 모두 문자열로 취급되어 결합됨.

<br><br>

### 문자열 → 기본 타입 캐스트

- byte - Byte.parseByte(str)
- short - Shory.parseShort(str)
- int - Integer.parseInteger(str)
- long - Long.parseLong(str)
- float - Float.parseFloat(str)
- double - Double.parseDouble(str)
- boolean - Boolean.parseBoolean(str)

<br>

### 기본 타입 → 문자열

- string - String.valueOf(기본타입값)

<br><br>

<h2>변수와 시스템 입출력</h2>

---

System.out.println(”출력 내용”);


위에서 System.out은 시스템의 표준 출력 장치를 말한다. out이 표준 출력 장치라면 표준 입력 장치는 다음과 같이 in을 사용한다. 

<br>

System.in.read();

<br>

**println()** - 출력 후, 줄바꿈

**print()** - 출력

**printf( ”형식 문자열”, 값1, 값2, … )** - 괄호 안의 첫 번째 문자열 형식대로 내용을 출력.

<br>

**System.in.read()** - 키보드에서 입력되는 코드를 하나씩 읽을 수 있음. enter는 캐리지 리턴(CR:13)과 라인 피드(LF:10)으로 구성된 2개의 키코드가 입력되기에, 내가 실제로 입력한 문자보다 2개의 실행문을 더 작성해야 한다.

<br>

**Scanner Class** - 자바에서 제공하는 시스템 입력 클래스. new Scanner(System.in) 으로 Scanner 객체를 생성하여 시스템의 입력 장치로부터 값을 받아올 수 있다. 입력되는 모든 내용은 String 으로 받을 수 있다.