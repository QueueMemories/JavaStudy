**객체 지향 언어에 대해 확실하게 이해하기 위해서는 참조 타입의 종류와 참조 변수의 역할이 무엇인지 먼저 이해해야 한다.**

<br>

자바에는 크게 기본 타입(primitive type)과 참조 타입(reference type)이 있다. 

<br>

- **기본 타입** - 정수, 실수, 문자, 논리 리터럴을 저장하는 타입이다.

- **참조 타입** - 객체(Object)의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스를 말한다.

<br>

기본 타입은 byte, char, short, int, long, float, double, boolean은 변수의 실제 값을 변수 안에 저장한다. 하지만, 참조 타입인 배열, 열거, 클래스, 인터페이스 변수는 메모리의 번지를 변수 안에 저장한다. 

<br>

즉, **번지**를 통해 **객체**를 **참조**한다는 뜻에서 **참조 타입**으로 불리운다.

<br>

## 메모리 사용 영역

---

JVM이 사용하는 메모리 영역에 대해 알아본다. JVM은 운영체제에서 할당받은 메모리 영역(Runtime Data Area)을 세부 영역으로 구분해서 사용한다.

<br>

**메모리 영역(Runtime Data Area)의 내부**
- 메소드 영역(Method Area)
    - 클래스 존재 (클래스 내부의 정적 필드/ 상수, 메소드 코드, 생성자 코드)
- 힙 영역(Heap Area)
    - 여러 참조 타입에 대한 객체들이 존재.
- JVM 스택(Stack)
    - 프레임에 따라 pop, push를 하는 공간.


<br>

### 메소드 영역

---

메소드 영역은(Method Area)은 JVM이 시작할 때, 생성되고 모든 스레드가 공유하는 영역이다. 메소드 영역에는 코드에서 사용되는 클래스(~.class) 들을 클래스 로더로 읽어 클래스별로 정적 필드(static field)와 상수(constant), 메소드 코드, 생성자(constructor) 코드 등을 분류해서 저장한다.

<br>

### 힙 영역

---

객체와 배열이 생성되는 영역. 여기에 생성된 객체와 배열들은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다. 만일 참조 카운트가 0이라면 JVM 내부에서 동작하는 쓰레기 수집기(Garbage Collector)를 실행시켜 자동으로 제거한다. 따라서, 개발자는 객체를 제거하기 위해 별도의 코드를 작성할 필요가 없다.

<br>

### JVM 스택 영역

---

메소드를 호출할 때마다 프레임(Frame)을 추가(push)하고 메소드가 종료되면 해당 프레임을 제거(pop)하는 동작을 수행한다. 

프레임 내부에는 로컬 변수 스택이 존재한다. 여기서는 기본 타입 변수와 참조 타입 변수가 추가(push) 되거나 제거(pop)된다. 스택 영역에 변수가 생성되는 시점은 초기화될 때이고, 선언시점이 아니다. 즉, 최초로 변수에 값이 저장될 때이고 변수는 선언된 블록 안에서만 유효하고, 블록을 벗어나게 되면 스택에서 제거된다.

<br>

```java
int[] scores = {10, 20, 30};
```

위 코드를 작성하면, 초기화 시점인 {10, 20, 30} 을 만났을 때, 스택 영역에 배열을 저장한다. 하지만, 자바에서 배열은 참조 타입이기 때문에, 실제 값은 heap 영역에 저장되고, 이 heap 영역에 저장된 번지 수가 stack 영역에 저장된다.

<br>

### ==, equals

---

기본 타입 변수의 ==, ≠ 연산은 변수의 값이 같은지, 아닌지를 조사하지만 참조 타입 변수들 간의 ==, ≠ 연산은 동일한 객체를 참조하는지, 다른 객체를 참조하는지 알아볼 때 사용된다. 

<br>

만일 어떤 객체1, 객체2가 heap연산에 존재한다고 가정한다. 이때, 스택영역에 존재하는 변수1, 변수2가 객체1을 참조하고 있다면, 객체1 == 객체2 의 값은 true가 나온다. 이는 값 자체를 비교하는 것이 아닌 스택 영역에 저장되어 있는 번지 수를 비교하는 것이기 때문이다. 

<br>

**그렇다면 만약에 값 자체가 같은 객체인지 판별하기 위해서는 어떻게 해야 할까?**

바로 .equals() 를 사용하면 된다. 변수1, 변수2가 각각 객체1, 객체2를 참조하고 있을 때, 그 내부의 값이 완벽하게 일치한다면, 변수1.equals(변수2) 의 값은 true가 된다.

<br>

### null, NullPointerException

---

참조 타입 변수는 힙 영역의 객체를 참조하지 않는다는 뜻으로 null 값을 가질 수 있다. null은 초기화값으로 사용할 수 있기에, null 로 초기화된 참조 변수는 스택 영역에 저장된다. 참조의 번지수 값을 비교하는 것이므로 변수1이 null인지 확인하기 위해서는 변수1 == null 로 비교하면 된다.

- **예외(Exception)** - 자바에서 프로그램 실행 도중에 발생하는 오류.
- **NullPointerException** - 참조 타입 변수를 잘못 사용하면 발생하는 예외. ****
    
    null 상태에서 있지도 않은 객체의 데이터(필드)나 메소드를 사용하는 코드를 실행하면 발생한다.

    <br>
    

### String 타입

---

자바는 문자열을 String 변수에 저장한다. 초기화는 “”로 감싼 문자열 리터럴을 대입한다. 문자열도 객체이므로, 스택 영역에 저장되지 않고, 힙 영역에 존재하는 String 객체에 문자가 저장되고, 이 번지수가 스택영역에 저장된다.

<br>

문제가 하나 있다. 자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 되어 있다. 

<br>

```java
String name1 = "문상우";
String name2 = "문상우";

name1 == name2      // true
name1.equals(name2) // true
```

위 같은 상황이 생길수도 있다. 이렇게 되면, 서로의 공유 영역을 참조하게 될 수도 있으므로 new 연산자를 사용해서 직접 새로운 String 객체를 생성시킬 수 있다.

<br>

**new 연산자** - 힙 영역에 새로운 객체를 만들 때 사용하는 연산자로 **객체 생성 연잔자**로 불리운다.

```java
String name1 = new String("문상우");
String name2 = new String("문상우");

name1 == name2       // false
name1.equals(name2)  // true
```

<br>

## 배열

---

많은 양의 데이터를 작은 코드로 처리할 수 있는 자료구조.

<br>

배열은 같은 타입의 데이터를 연속된 공간에 나열하고, 각 데이터에 인덱스(index)를 부여해놓은 자료구조이다. 인덱스는 항상 0부터 시작한다.

<br>

**배열의 특징**

1. 같은 타입의 데이터만 저장할 수 있다.
    
    선언 동시에 저장할 수 있는 타입이 결정되고, 다른 타입의 값을 저장하려고 하면 타입 불일치(Type mismatch) 컴파일 에러가 발생한다.
    
2. 한번 생성된 배열은 길이를 늘리거나 줄일 수 없다.
    
    만일 배열의 길이가 변경되어야 한다면 새로운 배열을 생성하고, 기존 배열 항목을 새 배열로 복사해야 한다.
    

    <br>

### 배열 선언

---

1. 타입[] 변수;
    
    ```java
    int[] intArray;
    double[] doubleArray;
    String[] strArray;
    ```
    
2. 타입 변수[];
    
    ```java
    int intArray[];
    double doubleArray[];
    String strArray[];
    ```
    

초기화를 위해 null을 사용할 수 있다. 하지만 실제로 힙 영역에 참조하고 있는 값이 없으므로, 변수[인덱스]로 값을 읽게 되면 NullPointerException이 발생한다.

<br>

### 배열 생성

---

- **값 목록으로 배열 생성**
    
    ```java
    타입[] 변수 = {값0, 값1, 값2};
    ```
    
    중괄호 {}는 주어진 값들을 항목으로 가지는 배열 객체를 힙에 생성하고, 배열 객체의 번지를 리턴한다.

    <br>
    
    위 방법은 무조건 선언과, 초기화를 동시에 진행해야 한다. 변수를 미리 생성하고 나중에 값 목록들이 정해진다면, new 연산자를 통해 배열을 생성해야 한다.
    
    <br>
    
    이는 초기화 때 뿐만 아니라, 메소드의 매개값이 배열일 경우에도 마찬가지이다.
    
    ```java
    int add(int[] scores) {...}
    
    int result = add( {95, 85, 90} );
    int result = add( new int[] { 95, 85, 90 } );
    ```

    <br>
    
- **new 연산자로 배열 생성**
    
    값의 목록을 가지고 있지 않고, 향후 값들을 저장할 배열을 미리 만들고 싶다면 new 연산자로 만들 수 있다.

    <br>
    
     
    
    ```java
    타입[] 변수 = new 타입[길이];
    ```
    
    위 명령어를 통해 배열을 생성했다면, 배열은 자동으로 기본값으로 초기화된다.

    <br>

    
    어떤 인덱스에 값을 대입하고 싶다면, 변수[인덱스] = 값; 으로 대입하면 된다.

    <br>
    

### 배열 길이

---

배열에 저장할 수 있는 전체 항목의 개수를 말한다.

<br>

배열변수.length; 문으로 간단하게 배열의 길이를 알 수 있다. length는 읽기 전용이기에 쓰기 접근이 들어가서는 안된다.

- ArrayIndexOutOfBoundsException - 배열의 최대 길이를 초과해서 접근한 경우.

<br>

### 명령 라인 입력

---

```java
public static void main(String[] args) { ... }
```

명령 라인(명령 프롬프트)에서 위 코드를 java 명령어로 실행하면 JVM은 길이가 0인 String 배열을 먼저 생성하고 main() 메소드를 호출할 때 매개값으로 전달한다. 

<br>

[JDK 11 이후 버전] java -p . -m 모듈명/패키지.클래스 문자열0 문자열1 문자열2 … 문자열n-1

위처럼 실행하면, JVM 은 아래와 같은 문자열 배열을 만들어 main 메소드에 인자로 전달한다.

<br>

```java
String[] args = { 문자열0, 문자열1, ..., 문자열n-1 };
// 

public static void main(String[] args) {
	...
}
```

main() 메소드는 String[] args 매개 변수를 통해서 명령 라인에서 입력된 데이터의 수(배열의 길이)와 입력된 데이터(배열의 항목 값)를 알 수 있게 된다.

<br>

- NumberFormatException - Integer.parseInt() 를 사용했을 때, 정수로 변환할 수 없는 문자열이 주어졌을 경우에 발생하는 예외

<br>

### 다차원 배열

---

행과 열로 구성된 배열을 2차원 배열이라고 한다.

<br>

**다차원 배열의 동작 원리**

1. int[][] scores = new int[2][3];
2. 스택 영역에 힙 영역을 참조하는 번지수 저장.
3. 힙 영역에는 int 타입 배열 A, int 타입 배열 B, int 타입 배열 C 이 생성.
    - 배열 A - length가 2인 배열 생성. index0은 배열 B 참조, index1은 배열 C 참조.
    - 배열 B - length가 3인 배열 생성. 안에 값은 int 형이므로 0으로 채워짐. (값이 들어감)
    - 배열 C - length가 3인 배열 생성. 안에 값은 int 형이므로 0으로 채워짐. (값이 들어감)

<br>

즉, 하나의 배열안에 모든 값이 들어가는 것이 아닌, 행만큼의 참조가 들어갈 공간을 가진 배열하나, 값을 가지고있는 하나의 행이 될 배열들이 생성되는 것이다. 따라서 수학 행렬 구조가 아닌 계단식 구조를 가질 수도 있다.

```java
int[][] scores = new int[2][];
scores[0] = new int[2]; // [0][1]
scores[1] = new int[3]; // [0][1][2]
```

```java
// 아래처럼 생성 가능.
int[][] scores = { {95, 80}, {92, 96} };
```