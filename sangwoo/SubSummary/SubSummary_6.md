## 객체 지향 프로그래밍(Object_Oriented Programming)

---

**객체** - 물리적으로 존재하거나, 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별이 가능한 것.

상태와 행위(속성과 동작 - 현실 세계의 객체)를 가지고, 이를 각각 **필드(field)** 와 **메소드(methode)** 라고 부른다.

<br>

**객체 모델링** - 현실 세계의 객체를 소프트웨어 객체로 설계하는 것.

즉, 현실 세계의 속성과 동작을 추려 소프트웨어 객체의 필드와 메소드로 정의하는 과정.

<br>

**클래스 변수** - 클래스로 선언한 변수, 해당 클래스의 객체 번지가 저장된다.

**인스턴스** - 객체는 클래스의 인스턴스

**클래스 멤버** - 클래스에 선언되는 멤버는 필드, 생성자, 메소드가 있다.

<br>

**객체에서 메소드 호출법.**

`객체.메소드(매개값1, 매개값2, …);`

도트 연산자(.) 는 객체의 필드와 메소드에 접근할 때 사용한다.

<br>

### 객체의 관계

<blockquote>

1. 집합 관계 - 어떤 객체는 완전체이고 이 완전체의 부품들의 관계를 집합 관계라고 함.
2. 사용 관계 - 어떤 객체가 다른 객체의 메소드를 호출하여 원하는 결과를 얻어 낸다면 이는 사용 관계.
3. 상속 관계 - 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계.

</blockquote>

<br>

**객체를 생성하는 순서**

개발자  →  클래스  →  객체(인스턴스)



개발자는 사용하고자 하는 객체를 구상하고 설계하여 클래스를 만든다. 이 클래스를 만들고 객체를 사용해야 할 때, 클래스를 인스턴스화 시킴으로 사용할 수 있다.

<br>

**클래스 선언**

```java
public class 클래스이름 {
}
```

통상적으로, 소스 파일당 하나의 클래스를 선언한다. 하지만, 하나의 소스 파일에 여러 클래스를 선언할 수 있고, 이 소스 파일을 컴파일 하면 바이트 코드 파일(.class)은 클래스를 선언한 개수만큼 생긴다.

<br>

> Tip
> 
> 
> 대신 public은 소스 파일의 이름과 동일한 클래스 선언에만 붙일 수 있다.


<br>

설계 후, 컴파일 된 클래스를 사용하기 위해서는 객체를 생성해야 한다. 

<br>

객체는 new 클래스(); 로 생성 가능하고, 객체의 메모리는 힙 영역에 생성된다. 이 객체 생성은 힙영역에 객체 저장 후, 저장된 번지를 반환하므로 클래스 변수에 이 번지를 넣어 객체를 사용할 수 있다.

<br>

클래스를 설계 할때, 두 가지 용도가 있다.

1. 라이브러리
2. 실행

100개의 클래스가 있다면 이 중 단 하나의 클래스가 실행 클래스이며, 나머지 99개의 클래스는 라이브러리이다.

<br>

## 클래스의 구성 멤버

---

필드(Field), 생성자(Constructor), 메소드(Method)

```java
public class ClassName {

	// 필드 - 객체의 데이터가 저장되는 곳
	int fieldname;

	// 생성자 - 객체 생성 시 초기화 역할 담당
	ClasssName() { ... }

	// 메소드 - 객체의 동작에 해당하는 실행 블록
	void methodName() { ... }

}
```

<br>

## 필드

---

**Field** - 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳.

<br>

선언 형태는 **변수(variable)** 와 비슷하지만, 필드를 변수라고 부르지 않는다. 변수의 유효 범위는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 종료 되면 소멸되지만, 필드는 생성자와 메소드 전체에서 사용되며 **객체가 소멸하지 않는 이상 객체와 함께 존재한다**.

<br>

### 필드 선언

---

중괄호 블록 {} 어디서든 존재할 수 있다. 생성자 선언, 메서드 선언의 앞 뒤 어디서든 필드 선언이 가능하지만, 그 내부에서는 선언할 수 없다.

<br>

```java
타입 필드 ( = 초기값 ) ;
```

초기값이 지정되지 않은 필드는 객체 생성 시, 자동으로 기본 초기값으로 설정된다. 초기값은 정수 타입 필드는 0, 실수 타입 필드는 0.0, boolean 필드는 false로 초기화되고, 참조 타입은 null 이 된다.

<br>

**변수와 필드의 가장 큰 차이점.**

**변수** - 자신이 선언된 생성자 또는 메소드 블록 내부에서만 사용할 수 있다.

**필드** - 생성자와 모든 메소드에서 사용이 가능하다.

<br>

## 생성자

---

**Constructor - new 연산자로 호출되는 특별한 중괄호 {} 블록이다.**

<br>

객체 생성 시 초기화를 담당한다. 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 할 수 있다. 메소드와 비슷하게 생겼지만, 클래스 이름으로 만들어야 하고 리턴 타입이 존재하지 않는다.

<br>

new 연산자를 사용했을 때, 호출되는 중괄호 {} 블록이다. 객체 생성 시 초기화를 담당하며, 모든 클래스에 반드시 하나 이상 존재한다. 이 때문에, 생성자를 생략하면 기본 생성자가 자동으로 추가된다.

<br>

**생성자** - new 연산자로 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.

**객체 초기화** - 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 한다.

**기본 생성자** - 모든 클래스는 생성자가 반드시 하나 이상 존재해야 하므로, 생성자 선언을 생략했다면 컴파일러는 블록 내용이 비어 있는 기본 생성자를 바이트 코드에 자동 추가한다. 즉, 클래스에 명시적으로 선언한 생성자가 1개라도 존재한다면, 기본 생성자는 자동으로 생성되지 않는다.

<br>

### 생성자 선언

---

생성자는 메서드와 비슷한 모양을 가지고 있지만, 리턴 타입이 없고 클래스 이름과 동일하다.

<br>

```java
클래스명 ( 매개변수 선언, ... ) {
	// 객체의 초기화 코드
}
```

<br>

매개 변수 선언은 생략할 수도 있고, 여러 개를 사용해도 된다. new 연산자를 사용할 때, 생성자에서 작성해놓은 매개 변수 선언에 맞게 매개값을 넘겨야 한다.

<br>

### 필드 초기화

---

필드는 변수와 다르게 클래스로부터 객체가 생성될 때, 기본 초기값으로 자동 설정된다.

<br>

다른 초기값 필드 값을 설정하는 방법

1. **필드를 선언할 때, 초기값을 설정하는 방법.**
    
    동인한 클래스로부터 생성되는 객체들은 필드 값이 모두 같아진다.

<br>
    
2. **생성자에서 초기값을 주는 방법.**
    
    객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 할 때, 사용한다.

    <br>
    
    ```java
    public class Korean {
    	String nation = "대한민국";
    	String name;
    
    	public Korean (String n) {
    		name = n;
    	}
    }
    
    // 외부에서 호출
    Korean k1 = new Korean("문상우");
    ```
    
    위 방법을 사용하면, 필드 name의 값은 객체를 생성할 때, 넘어온 “문상우”로 초기화된다. 하지만, 보통 필드 값과 매개 변수의 값을 동일하게 작성한다. 이 때, 이름이 동일하다면 동일한 매개변수의 우선 순위가 높기 때문에 필드 명과 매개 변수 명이 동일한 상태에서 위 코드를 작성하기 위해서는 필드 변수 앞에 this. 를 붙여야 한다.

    <br>
    
    this 는 객체 자신의 참조이다. 

    <br>
    
    ```java
    public class Korean {
    	String nation = "대한민국";
    	String name;
    
    	public Korean (String name) {
    		this.name = name;
    	}
    }
    
    // 외부에서 호출
    Korean k1 = new Korean("문상우");
    ```
    

<br>

### 생성자 오버로딩

---

하나의 클래스 안에서 생성자를 여러개 선언하는 것을 말한다. 받는 매개 변수의 값을 달리하면 생성자를 여러개 생성할 수 있다.

<br>

```java
public class Car {
	Car () { ... };
	Car (String model) { ... };
	Car (String model, String color) { ... };
}
```

위에서 주의해야 할 점은 매개 변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우 매개변수 이름만 바꾸는 것은 생성자 오버로딩이 아니다.  

<br>

```java
public class Car {
	Car (String model, String color) { ... };
	Car (String color, String model) { ... };
}
// 이는 생성자 오버로딩이 아니다.
```

<br>

**this(객체 자신) 를 이용하여 생성자 내부에서 다른 생성자를 호출할 수 있다**

생성자 오버로딩이 많아진다면 자연스럽게 생성자 간의 중복된 코드가 발생할 수 있다. 따라서, 매개 변수의 수만 달리하고 필드 초기화 내용이 비슷한 생성자에서 이런 현상을 많이 볼 수 있다.

<br>

즉, 필드 초기화 내용은 한 생성자에서 집중적으로 작성하고 나머지는 생성자 초기화 내용을 가지고 있는 생성자를 호출하는 방법을 사용한다. 그리고 하나의 객체 안의 다른 생성자를 호출하기 위해서는 this() 를 이용한다.

<br>

this() 를 사용할 때는 반드시 생성자 블록안에서 첫 줄에서만 허용된다. this() 에서도 동일하게 호출하는 생성자의 매개변수에 맞게 호출해야 한다.

<br>

```java
Car (String model) {
	this.model = model;
	this.color = "은색";
	this.maxSpeed = 250;
}

Car (String model, String color) {
	this.model = model;
	this.color = color;
	this.maxSpeed = 250;
}

Car (String model, String color, int maxSpeed) {
	this.model = model;
	this.color = color;
	this.maxSpeed = maxSpeed;
}
```

위 코드를 보면 중복되는 코드가 발생한다. 이 때, this()를 사용한다.

<br>

```java
Car (String model) {
	this(model, "은색", "250");
}

Car (String model, String color) {
	this(model, color, "250");
}

Car (String model, String color, int maxSpeed) {
	this.model = model;
	this.color = color;
	this.maxSpeed = maxSpeed;
}
```

위 코드처럼 this() 를 사용하여 중복되는 코드를 줄이고, 코드를 간결하게 작성할 수 있다.