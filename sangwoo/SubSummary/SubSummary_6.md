## 객체 지향 프로그래밍(Object_Oriented Programming)

---

**객체** - 물리적으로 존재하거나, 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별이 가능한 것.

상태와 행위(속성과 동작 - 현실 세계의 객체)를 가지고, 이를 각각 **필드(field)** 와 **메소드(methode)** 라고 부른다.

<br>

**객체 모델링** - 현실 세계의 객체를 소프트웨어 객체로 설계하는 것.

즉, 현실 세계의 속성과 동작을 추려 소프트웨어 객체의 필드와 메소드로 정의하는 과정.

<br>

**클래스 변수** - 클래스로 선언한 변수, 해당 클래스의 객체 번지가 저장된다.

**인스턴스** - 객체는 클래스의 인스턴스

**클래스 멤버** - 클래스에 선언되는 멤버는 필드, 생성자, 메소드가 있다.

<br>

**객체에서 메소드 호출법.**

`객체.메소드(매개값1, 매개값2, …);`

도트 연산자(.) 는 객체의 필드와 메소드에 접근할 때 사용한다.

<br>

### 객체의 관계

<blockquote>

1. 집합 관계 - 어떤 객체는 완전체이고 이 완전체의 부품들의 관계를 집합 관계라고 함.
2. 사용 관계 - 어떤 객체가 다른 객체의 메소드를 호출하여 원하는 결과를 얻어 낸다면 이는 사용 관계.
3. 상속 관계 - 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계.

</blockquote>

<br>

**객체를 생성하는 순서**

개발자  →  클래스  →  객체(인스턴스)



개발자는 사용하고자 하는 객체를 구상하고 설계하여 클래스를 만든다. 이 클래스를 만들고 객체를 사용해야 할 때, 클래스를 인스턴스화 시킴으로 사용할 수 있다.

<br>

**클래스 선언**

```java
public class 클래스이름 {
}
```

통상적으로, 소스 파일당 하나의 클래스를 선언한다. 하지만, 하나의 소스 파일에 여러 클래스를 선언할 수 있고, 이 소스 파일을 컴파일 하면 바이트 코드 파일(.class)은 클래스를 선언한 개수만큼 생긴다.

<br>

> Tip
> 
> 
> 대신 public은 소스 파일의 이름과 동일한 클래스 선언에만 붙일 수 있다.


<br>

설계 후, 컴파일 된 클래스를 사용하기 위해서는 객체를 생성해야 한다. 

<br>

객체는 new 클래스(); 로 생성 가능하고, 객체의 메모리는 힙 영역에 생성된다. 이 객체 생성은 힙영역에 객체 저장 후, 저장된 번지를 반환하므로 클래스 변수에 이 번지를 넣어 객체를 사용할 수 있다.

<br>

클래스를 설계 할때, 두 가지 용도가 있다.

1. 라이브러리
2. 실행

100개의 클래스가 있다면 이 중 단 하나의 클래스가 실행 클래스이며, 나머지 99개의 클래스는 라이브러리이다.

<br>

## 클래스의 구성 멤버

---

필드(Field), 생성자(Constructor), 메소드(Method)

```java
public class ClassName {

	// 필드 - 객체의 데이터가 저장되는 곳
	int fieldname;

	// 생성자 - 객체 생성 시 초기화 역할 담당
	ClasssName() { ... }

	// 메소드 - 객체의 동작에 해당하는 실행 블록
	void methodName() { ... }

}
```

<br>

## 필드

---

**Field** - 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳.

<br>

선언 형태는 **변수(variable)** 와 비슷하지만, 필드를 변수라고 부르지 않는다. 변수의 유효 범위는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 종료 되면 소멸되지만, 필드는 생성자와 메소드 전체에서 사용되며 **객체가 소멸하지 않는 이상 객체와 함께 존재한다**.

<br>

### 필드 선언

---

중괄호 블록 {} 어디서든 존재할 수 있다. 생성자 선언, 메서드 선언의 앞 뒤 어디서든 필드 선언이 가능하지만, 그 내부에서는 선언할 수 없다.

<br>

```java
타입 필드 ( = 초기값 ) ;
```

초기값이 지정되지 않은 필드는 객체 생성 시, 자동으로 기본 초기값으로 설정된다. 초기값은 정수 타입 필드는 0, 실수 타입 필드는 0.0, boolean 필드는 false로 초기화되고, 참조 타입은 null 이 된다.

<br>

**변수와 필드의 가장 큰 차이점.**

**변수** - 자신이 선언된 생성자 또는 메소드 블록 내부에서만 사용할 수 있다.

**필드** - 생성자와 모든 메소드에서 사용이 가능하다.

<br>

## 생성자

---

**Constructor - new 연산자로 호출되는 특별한 중괄호 {} 블록이다.**

<br>

객체 생성 시 초기화를 담당한다. 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 할 수 있다. 메소드와 비슷하게 생겼지만, 클래스 이름으로 만들어야 하고 리턴 타입이 존재하지 않는다.

<br>

new 연산자를 사용했을 때, 호출되는 중괄호 {} 블록이다. 객체 생성 시 초기화를 담당하며, 모든 클래스에 반드시 하나 이상 존재한다. 이 때문에, 생성자를 생략하면 기본 생성자가 자동으로 추가된다.

<br>

**생성자** - new 연산자로 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.

**객체 초기화** - 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 한다.

**기본 생성자** - 모든 클래스는 생성자가 반드시 하나 이상 존재해야 하므로, 생성자 선언을 생략했다면 컴파일러는 블록 내용이 비어 있는 기본 생성자를 바이트 코드에 자동 추가한다. 즉, 클래스에 명시적으로 선언한 생성자가 1개라도 존재한다면, 기본 생성자는 자동으로 생성되지 않는다.

<br>

### 생성자 선언

---

생성자는 메서드와 비슷한 모양을 가지고 있지만, 리턴 타입이 없고 클래스 이름과 동일하다.

<br>

```java
클래스명 ( 매개변수 선언, ... ) {
	// 객체의 초기화 코드
}
```

<br>

매개 변수 선언은 생략할 수도 있고, 여러 개를 사용해도 된다. new 연산자를 사용할 때, 생성자에서 작성해놓은 매개 변수 선언에 맞게 매개값을 넘겨야 한다.

<br>

### 필드 초기화

---

필드는 변수와 다르게 클래스로부터 객체가 생성될 때, 기본 초기값으로 자동 설정된다.

<br>

다른 초기값 필드 값을 설정하는 방법

1. **필드를 선언할 때, 초기값을 설정하는 방법.**
    
    동인한 클래스로부터 생성되는 객체들은 필드 값이 모두 같아진다.

<br>
    
2. **생성자에서 초기값을 주는 방법.**
    
    객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 할 때, 사용한다.

    <br>
    
    ```java
    public class Korean {
    	String nation = "대한민국";
    	String name;
    
    	public Korean (String n) {
    		name = n;
    	}
    }
    
    // 외부에서 호출
    Korean k1 = new Korean("문상우");
    ```
    
    위 방법을 사용하면, 필드 name의 값은 객체를 생성할 때, 넘어온 “문상우”로 초기화된다. 하지만, 보통 필드 값과 매개 변수의 값을 동일하게 작성한다. 이 때, 이름이 동일하다면 동일한 매개변수의 우선 순위가 높기 때문에 필드 명과 매개 변수 명이 동일한 상태에서 위 코드를 작성하기 위해서는 필드 변수 앞에 this. 를 붙여야 한다.

    <br>
    
    this 는 객체 자신의 참조이다. 

    <br>
    
    ```java
    public class Korean {
    	String nation = "대한민국";
    	String name;
    
    	public Korean (String name) {
    		this.name = name;
    	}
    }
    
    // 외부에서 호출
    Korean k1 = new Korean("문상우");
    ```
    

<br>

### 생성자 오버로딩

---

하나의 클래스 안에서 생성자를 여러개 선언하는 것을 말한다. 받는 매개 변수의 값을 달리하면 생성자를 여러개 생성할 수 있다.

<br>

```java
public class Car {
	Car () { ... };
	Car (String model) { ... };
	Car (String model, String color) { ... };
}
```

위에서 주의해야 할 점은 매개 변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우 매개변수 이름만 바꾸는 것은 생성자 오버로딩이 아니다.  

<br>

```java
public class Car {
	Car (String model, String color) { ... };
	Car (String color, String model) { ... };
}
// 이는 생성자 오버로딩이 아니다.
```

<br>

**this(객체 자신) 를 이용하여 생성자 내부에서 다른 생성자를 호출할 수 있다**

생성자 오버로딩이 많아진다면 자연스럽게 생성자 간의 중복된 코드가 발생할 수 있다. 따라서, 매개 변수의 수만 달리하고 필드 초기화 내용이 비슷한 생성자에서 이런 현상을 많이 볼 수 있다.

<br>

즉, 필드 초기화 내용은 한 생성자에서 집중적으로 작성하고 나머지는 생성자 초기화 내용을 가지고 있는 생성자를 호출하는 방법을 사용한다. 그리고 하나의 객체 안의 다른 생성자를 호출하기 위해서는 this() 를 이용한다.

<br>

this() 를 사용할 때는 반드시 생성자 블록안에서 첫 줄에서만 허용된다. this() 에서도 동일하게 호출하는 생성자의 매개변수에 맞게 호출해야 한다.

<br>

```java
Car (String model) {
	this.model = model;
	this.color = "은색";
	this.maxSpeed = 250;
}

Car (String model, String color) {
	this.model = model;
	this.color = color;
	this.maxSpeed = 250;
}

Car (String model, String color, int maxSpeed) {
	this.model = model;
	this.color = color;
	this.maxSpeed = maxSpeed;
}
```

위 코드를 보면 중복되는 코드가 발생한다. 이 때, this()를 사용한다.

<br>

```java
Car (String model) {
	this(model, "은색", "250");
}

Car (String model, String color) {
	this(model, color, "250");
}

Car (String model, String color, int maxSpeed) {
	this.model = model;
	this.color = color;
	this.maxSpeed = maxSpeed;
}
```

위 코드처럼 this() 를 사용하여 중복되는 코드를 줄이고, 코드를 간결하게 작성할 수 있다.

<br>

## 메서드

---

Method - 객체의 동작에 해당하는 중괄호 {} 블록을 말한다.

<br>

메소드를 호출하면 메소드 내부의 모든 코드들이 실행된다. 이때, 메소드는 필드를 읽고 수정하는 역할을 하지만, 다른 객체를 생성해 다양한 기능을 수행할 수도 있다. 즉, 객체 간의 데이터를 전달하는 수단이다.

<br>

메소드 선언은 **선언부**와 **실행 블록**으로 구성된다. 메소드 선언부는 메소드 시그너처(method signature) 라고 한다.

<br>

**선언부**

- 리턴 타입 - 메소드가 리턴하는 결과의 타입을 표시한다(리턴값의 타입).
    
    리턴값 - 메소드를 실행한 후의 결과값을 말한다. 리턴값은 있을 수도 없을 수도 있지만, 있는 경우에 리턴 타입은 선언부에 꼭 명시되어야 한다(없을때는 void).
    
    리턴값에 맞는 타입에 변수를 저장해야 한다. 하지만, 리턴값 자체는 중요하지 않고 메소드 실행이 중요한 경우에는 변수를 선언하지 않고 메소드를 호출할 수도 있다.
    
    ```java
    리턴타입 변수 = 메서드(매개변수1, 매개변수2, ...);
    메서드(매개변수1, 매개변수2, ...);
    // 두가지 모두 가능
    ```

<br>
    
- 메소드 이름 - 메소드의 기능이 드러나도록 식별자 규칙에 맞게 이름을 지어준다.
    - 숫자 시작x, $, _ 두개의 특수 문자만 가능
    - 소문자 이름으로 시작, 다른 단어와 합성되면 뒤이어 오는 단어의 첫 글자는 대문자로 작성.
    - 메서드를 작성할 때는 대부분 동사, 기능을 위주로 작성하는 것이 좋다.
    - 이름의 길이가 실행속도에 영향을 끼치지 않으므로 조금 길더라도 자세하게 작성하는 것이 중요하다.

<br>
    
- 매개 변수 선언 - 메소드를 실행할 때, 필요한 데이터를 받기 위한 변수를 선언한다.
    
    메소드에서는 필요한 데이터를 받기 위해 필요한 만큼 매개 변수의 타입과 수를 지정하고, 이 메서드를 호출할 때는 항상 타입과 메서드 순서와 수를 맞추어서 호출해야 한다.

    <br>
    
    **매개 변수의 개수를 모를 경우**
    
    보통의 메소드에서는 매개 변수의 개수가 미리 정해져 있지만, 어떤 상황에서는 메서드를 선언할 때 매개 변수의 개수를 알 수 없는 경우도 있다.

    <br>
    
    위 상황 해결하는 2가지 방법.
    
    1. **배개 변수를 배열 타입으로 선언**
        
        ```java
        // 임의의 개수의 수를 받는 덧셈 메서드
        int allSum (int[] valuse) {  }
        
        // 호출시
        int[] values = { 1, 2, 3 };
        int result1 = sum1(values);
        int result2 = sum1(new int[] { 1, 2, 3, 4, 5 });
        ```
        
        하지만, 위 방법을 사용하면 메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있다.

    <br>
        
    2. **나머지 매개변수**
        
        이 방법을 사용하면 배열을 생성하지 않고, 값의 목록만 넘겨주는 방법이 있다. 매개 변수 … 을 사용하면 선언하게 되면 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.
        
        ```java
        int sum2 (int ... values) { }
        ```
        
        매개 변수 … 를 사용하기 위해서는 메소드 호출 시 쉼표로 나열해주면 된다.
        
        ```java
        int result1 = sum2(1, 2, 3);
        int result2 = sum2(1, 2, 3, 4, 5);
        
        // 아래와 같이 사용해도 상관 없다.
        // 즉, 결국 이 방법도 배열을 사용한다는 뜻.
        int[] values = { 1, 2, 3 };
        int result1 = sum1(values);
        int result2 = sum1(new int[] { 1, 2, 3, 4, 5 });
        ```

<br>
        

**실행 블록**

- 메소드 실행 블록 - 실행할 코드를 작성한다.

```java
리턴타입 메소드이름 ( 매개변수 선언1, 매개변수 선언2, ... ) {
	// 메소드 실행 블록(실행할 코드)
}
```

<br>

### 리턴문(return) 문

---

> **리턴값이 있는 메서드**
> 
> 
> 메서드 선언에서 리턴 타입이 있는 메소드는 반드시 return 문을 사용해서 리턴값을 지정해줘야 한다. 만일 return 문이 없다면 컴파일 에러가 발생하고, return 문이 실행되면 메소드는 값을 즉시 반환하고 종료된다.
>
> 
> return 값에는 리턴 타입, 또는 리턴 타입으로 자동 변환될 수 있는 값들이 있어야 한다. 예) 리턴 타입이 int면 메서드에서는 byte, short, int 의 값이 리턴되어도 상관없다는 뜻이다.
> 

<br>

> **리턴값이 없는 메소드 : void**
> 
> 
> 이 경우에 사용되는 return은 반환값을 전달하기 위한 용도가 아닌, 메소드 실행을 강제 종료시킬 때, 사용된다.
> 

<br>

### 메서드 호출

---

메서드는 클래스 내 & 외부의 호출에 의해 실행된다. 클래스 내부의 다른 메서드에서 호출할 경웨는 단순한 메서드 이름으로 호출하면 되고, 클래스 외부에서 호출할 때는 클래스로부터 객체를 생성한 뒤 참조 변수를 이용하여 메서드를 호출해야 한다.

<br>

**객체 내부에서 호출**

`메서드( 매개값, … );`

이것도 동일하게, 리턴 타입 변수에 할당할 수 있고, 자동 타입 변환이 될 수 있는 값이면 가능하다. int → double로 할당 가능.

<br>

**객체 외부에서 호출**

`클래스 참조변수 = new 클래스( 매개값, … );`

위 참조 변수와 함께 도트(.)를 사용하여 메서드를 호출할 수 있다. 이는 객체 접근 연산자로 객체가 가지고 있는 필드나 메서드에 접근할 때 사용한다.

`참조변수.메서드( 매개값, … );`

<br>

### 메서드 오버로딩

---

클래스 내에 같은 이름의 메서드를 여러 개 선언한느 것을 메서드 오버로딩(overloading)이라고 한다.

<br>

메서드 오버로딩의 조건은,

1. 매개 변수의 타입
2. 매개 변수의 개수
3. 매개 변수의 순서

위 네개이다.

<br>

주의할 점은 위 세개가 같고 리턴 타입만 다른 경우이다. 이때 JVM은 오버로딩 되어 있는 어떤 메서드를 선택해야 하는지 아직 모르기에 컴파일 에러가 발생한다.

```java
int divide(int x, int y) { ... }
double divide(int moonX, int moonY) { ... }
// 리턴 타입만 다른 경우.
```