## 객체 지향 프로그래밍(Object_Oriented Programming)

---

**객체** - 물리적으로 존재하거나, 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있으면서 식별이 가능한 것.

상태와 행위(속성과 동작 - 현실 세계의 객체)를 가지고, 이를 각각 **필드(field)** 와 **메소드(methode)** 라고 부른다.

<br>

**객체 모델링** - 현실 세계의 객체를 소프트웨어 객체로 설계하는 것.

즉, 현실 세계의 속성과 동작을 추려 소프트웨어 객체의 필드와 메소드로 정의하는 과정.

<br>

**클래스 변수** - 클래스로 선언한 변수, 해당 클래스의 객체 번지가 저장된다.

**인스턴스** - 객체는 클래스의 인스턴스

**클래스 멤버** - 클래스에 선언되는 멤버는 필드, 생성자, 메소드가 있다.

<br>

**객체에서 메소드 호출법.**

`객체.메소드(매개값1, 매개값2, …);`

도트 연산자(.) 는 객체의 필드와 메소드에 접근할 때 사용한다.

<br>

### 객체의 관계

<blockquote>

1. 집합 관계 - 어떤 객체는 완전체이고 이 완전체의 부품들의 관계를 집합 관계라고 함.
2. 사용 관계 - 어떤 객체가 다른 객체의 메소드를 호출하여 원하는 결과를 얻어 낸다면 이는 사용 관계.
3. 상속 관계 - 상위(부모) 객체를 기반으로 하위(자식) 객체를 생성하는 관계.

</blockquote>

<br>

**객체를 생성하는 순서**

개발자  →  클래스  →  객체(인스턴스)



개발자는 사용하고자 하는 객체를 구상하고 설계하여 클래스를 만든다. 이 클래스를 만들고 객체를 사용해야 할 때, 클래스를 인스턴스화 시킴으로 사용할 수 있다.

<br>

**클래스 선언**

```java
public class 클래스이름 {
}
```

통상적으로, 소스 파일당 하나의 클래스를 선언한다. 하지만, 하나의 소스 파일에 여러 클래스를 선언할 수 있고, 이 소스 파일을 컴파일 하면 바이트 코드 파일(.class)은 클래스를 선언한 개수만큼 생긴다.

<br>

> Tip
> 
> 
> 대신 public은 소스 파일의 이름과 동일한 클래스 선언에만 붙일 수 있다.


<br>

설계 후, 컴파일 된 클래스를 사용하기 위해서는 객체를 생성해야 한다. 

<br>

객체는 new 클래스(); 로 생성 가능하고, 객체의 메모리는 힙 영역에 생성된다. 이 객체 생성은 힙영역에 객체 저장 후, 저장된 번지를 반환하므로 클래스 변수에 이 번지를 넣어 객체를 사용할 수 있다.

<br>

클래스를 설계 할때, 두 가지 용도가 있다.

1. 라이브러리
2. 실행

100개의 클래스가 있다면 이 중 단 하나의 클래스가 실행 클래스이며, 나머지 99개의 클래스는 라이브러리이다.

<br>

## 클래스의 구성 멤버

---

필드(Field), 생성자(Constructor), 메소드(Method)

```java
public class ClassName {

	// 필드 - 객체의 데이터가 저장되는 곳
	int fieldname;

	// 생성자 - 객체 생성 시 초기화 역할 담당
	ClasssName() { ... }

	// 메소드 - 객체의 동작에 해당하는 실행 블록
	void methodName() { ... }

}
```

<br>

## 필드

---

**Field** - 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳.

<br>

선언 형태는 **변수(variable)** 와 비슷하지만, 필드를 변수라고 부르지 않는다. 변수의 유효 범위는 생성자와 메소드 내에서만 사용되고 생성자와 메소드가 종료 되면 소멸되지만, 필드는 생성자와 메소드 전체에서 사용되며 **객체가 소멸하지 않는 이상 객체와 함께 존재한다**.

<br>

### 필드 선언

---

중괄호 블록 {} 어디서든 존재할 수 있다. 생성자 선언, 메서드 선언의 앞 뒤 어디서든 필드 선언이 가능하지만, 그 내부에서는 선언할 수 없다.

<br>

```java
타입 필드 ( = 초기값 ) ;
```

초기값이 지정되지 않은 필드는 객체 생성 시, 자동으로 기본 초기값으로 설정된다. 초기값은 정수 타입 필드는 0, 실수 타입 필드는 0.0, boolean 필드는 false로 초기화되고, 참조 타입은 null 이 된다.

<br>

**변수와 필드의 가장 큰 차이점.**

**변수** - 자신이 선언된 생성자 또는 메소드 블록 내부에서만 사용할 수 있다.

**필드** - 생성자와 모든 메소드에서 사용이 가능하다.

<br>

## 생성자

---

**Constructor - new 연산자로 호출되는 특별한 중괄호 {} 블록이다.**

<br>

객체 생성 시 초기화를 담당한다. 필드를 초기화하거나, 메소드를 호출해서 객체를 사용할 준비를 할 수 있다. 메소드와 비슷하게 생겼지만, 클래스 이름으로 만들어야 하고 리턴 타입이 존재하지 않는다.

<br>

new 연산자를 사용했을 때, 호출되는 중괄호 {} 블록이다. 객체 생성 시 초기화를 담당하며, 모든 클래스에 반드시 하나 이상 존재한다. 이 때문에, 생성자를 생략하면 기본 생성자가 자동으로 추가된다.

<br>

**생성자** - new 연산자로 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다.

**객체 초기화** - 필드를 초기화하거나 메소드를 호출해서 객체를 사용할 준비를 한다.

**기본 생성자** - 모든 클래스는 생성자가 반드시 하나 이상 존재해야 하므로, 생성자 선언을 생략했다면 컴파일러는 블록 내용이 비어 있는 기본 생성자를 바이트 코드에 자동 추가한다. 즉, 클래스에 명시적으로 선언한 생성자가 1개라도 존재한다면, 기본 생성자는 자동으로 생성되지 않는다.

<br>

### 생성자 선언

---

생성자는 메서드와 비슷한 모양을 가지고 있지만, 리턴 타입이 없고 클래스 이름과 동일하다.

<br>

```java
클래스명 ( 매개변수 선언, ... ) {
	// 객체의 초기화 코드
}
```

<br>

매개 변수 선언은 생략할 수도 있고, 여러 개를 사용해도 된다. new 연산자를 사용할 때, 생성자에서 작성해놓은 매개 변수 선언에 맞게 매개값을 넘겨야 한다.

<br>

### 필드 초기화

---

필드는 변수와 다르게 클래스로부터 객체가 생성될 때, 기본 초기값으로 자동 설정된다.

<br>

다른 초기값 필드 값을 설정하는 방법

1. **필드를 선언할 때, 초기값을 설정하는 방법.**
    
    동인한 클래스로부터 생성되는 객체들은 필드 값이 모두 같아진다.

<br>
    
2. **생성자에서 초기값을 주는 방법.**
    
    객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 할 때, 사용한다.

    <br>
    
    ```java
    public class Korean {
    	String nation = "대한민국";
    	String name;
    
    	public Korean (String n) {
    		name = n;
    	}
    }
    
    // 외부에서 호출
    Korean k1 = new Korean("문상우");
    ```
    
    위 방법을 사용하면, 필드 name의 값은 객체를 생성할 때, 넘어온 “문상우”로 초기화된다. 하지만, 보통 필드 값과 매개 변수의 값을 동일하게 작성한다. 이 때, 이름이 동일하다면 동일한 매개변수의 우선 순위가 높기 때문에 필드 명과 매개 변수 명이 동일한 상태에서 위 코드를 작성하기 위해서는 필드 변수 앞에 this. 를 붙여야 한다.

    <br>
    
    this 는 객체 자신의 참조이다. 

    <br>
    
    ```java
    public class Korean {
    	String nation = "대한민국";
    	String name;
    
    	public Korean (String name) {
    		this.name = name;
    	}
    }
    
    // 외부에서 호출
    Korean k1 = new Korean("문상우");
    ```
    

<br>

### 생성자 오버로딩

---

하나의 클래스 안에서 생성자를 여러개 선언하는 것을 말한다. 받는 매개 변수의 값을 달리하면 생성자를 여러개 생성할 수 있다.

<br>

```java
public class Car {
	Car () { ... };
	Car (String model) { ... };
	Car (String model, String color) { ... };
}
```

위에서 주의해야 할 점은 매개 변수의 타입과 개수 그리고 선언된 순서가 똑같을 경우 매개변수 이름만 바꾸는 것은 생성자 오버로딩이 아니다.  

<br>

```java
public class Car {
	Car (String model, String color) { ... };
	Car (String color, String model) { ... };
}
// 이는 생성자 오버로딩이 아니다.
```

<br>

**this(객체 자신) 를 이용하여 생성자 내부에서 다른 생성자를 호출할 수 있다**

생성자 오버로딩이 많아진다면 자연스럽게 생성자 간의 중복된 코드가 발생할 수 있다. 따라서, 매개 변수의 수만 달리하고 필드 초기화 내용이 비슷한 생성자에서 이런 현상을 많이 볼 수 있다.

<br>

즉, 필드 초기화 내용은 한 생성자에서 집중적으로 작성하고 나머지는 생성자 초기화 내용을 가지고 있는 생성자를 호출하는 방법을 사용한다. 그리고 하나의 객체 안의 다른 생성자를 호출하기 위해서는 this() 를 이용한다.

<br>

this() 를 사용할 때는 반드시 생성자 블록안에서 첫 줄에서만 허용된다. this() 에서도 동일하게 호출하는 생성자의 매개변수에 맞게 호출해야 한다.

<br>

```java
Car (String model) {
	this.model = model;
	this.color = "은색";
	this.maxSpeed = 250;
}

Car (String model, String color) {
	this.model = model;
	this.color = color;
	this.maxSpeed = 250;
}

Car (String model, String color, int maxSpeed) {
	this.model = model;
	this.color = color;
	this.maxSpeed = maxSpeed;
}
```

위 코드를 보면 중복되는 코드가 발생한다. 이 때, this()를 사용한다.

<br>

```java
Car (String model) {
	this(model, "은색", "250");
}

Car (String model, String color) {
	this(model, color, "250");
}

Car (String model, String color, int maxSpeed) {
	this.model = model;
	this.color = color;
	this.maxSpeed = maxSpeed;
}
```

위 코드처럼 this() 를 사용하여 중복되는 코드를 줄이고, 코드를 간결하게 작성할 수 있다.

<br>

## 메서드

---

Method - 객체의 동작에 해당하는 중괄호 {} 블록을 말한다.

<br>

메소드를 호출하면 메소드 내부의 모든 코드들이 실행된다. 이때, 메소드는 필드를 읽고 수정하는 역할을 하지만, 다른 객체를 생성해 다양한 기능을 수행할 수도 있다. 즉, 객체 간의 데이터를 전달하는 수단이다.

<br>

메소드 선언은 **선언부**와 **실행 블록**으로 구성된다. 메소드 선언부는 메소드 시그너처(method signature) 라고 한다.

<br>

**선언부**

- 리턴 타입 - 메소드가 리턴하는 결과의 타입을 표시한다(리턴값의 타입).
    
    리턴값 - 메소드를 실행한 후의 결과값을 말한다. 리턴값은 있을 수도 없을 수도 있지만, 있는 경우에 리턴 타입은 선언부에 꼭 명시되어야 한다(없을때는 void).
    
    리턴값에 맞는 타입에 변수를 저장해야 한다. 하지만, 리턴값 자체는 중요하지 않고 메소드 실행이 중요한 경우에는 변수를 선언하지 않고 메소드를 호출할 수도 있다.
    
    ```java
    리턴타입 변수 = 메서드(매개변수1, 매개변수2, ...);
    메서드(매개변수1, 매개변수2, ...);
    // 두가지 모두 가능
    ```

<br>
    
- 메소드 이름 - 메소드의 기능이 드러나도록 식별자 규칙에 맞게 이름을 지어준다.
    - 숫자 시작x, $, _ 두개의 특수 문자만 가능
    - 소문자 이름으로 시작, 다른 단어와 합성되면 뒤이어 오는 단어의 첫 글자는 대문자로 작성.
    - 메서드를 작성할 때는 대부분 동사, 기능을 위주로 작성하는 것이 좋다.
    - 이름의 길이가 실행속도에 영향을 끼치지 않으므로 조금 길더라도 자세하게 작성하는 것이 중요하다.

<br>
    
- 매개 변수 선언 - 메소드를 실행할 때, 필요한 데이터를 받기 위한 변수를 선언한다.
    
    메소드에서는 필요한 데이터를 받기 위해 필요한 만큼 매개 변수의 타입과 수를 지정하고, 이 메서드를 호출할 때는 항상 타입과 메서드 순서와 수를 맞추어서 호출해야 한다.

    <br>
    
    **매개 변수의 개수를 모를 경우**
    
    보통의 메소드에서는 매개 변수의 개수가 미리 정해져 있지만, 어떤 상황에서는 메서드를 선언할 때 매개 변수의 개수를 알 수 없는 경우도 있다.

    <br>
    
    위 상황 해결하는 2가지 방법.
    
    1. **배개 변수를 배열 타입으로 선언**
        
        ```java
        // 임의의 개수의 수를 받는 덧셈 메서드
        int allSum (int[] valuse) {  }
        
        // 호출시
        int[] values = { 1, 2, 3 };
        int result1 = sum1(values);
        int result2 = sum1(new int[] { 1, 2, 3, 4, 5 });
        ```
        
        하지만, 위 방법을 사용하면 메소드를 호출하기 전에 배열을 생성해야 하는 불편한 점이 있다.

    <br>
        
    2. **나머지 매개변수**
        
        이 방법을 사용하면 배열을 생성하지 않고, 값의 목록만 넘겨주는 방법이 있다. 매개 변수 … 을 사용하면 선언하게 되면 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.
        
        ```java
        int sum2 (int ... values) { }
        ```
        
        매개 변수 … 를 사용하기 위해서는 메소드 호출 시 쉼표로 나열해주면 된다.
        
        ```java
        int result1 = sum2(1, 2, 3);
        int result2 = sum2(1, 2, 3, 4, 5);
        
        // 아래와 같이 사용해도 상관 없다.
        // 즉, 결국 이 방법도 배열을 사용한다는 뜻.
        int[] values = { 1, 2, 3 };
        int result1 = sum1(values);
        int result2 = sum1(new int[] { 1, 2, 3, 4, 5 });
        ```

<br>
        

**실행 블록**

- 메소드 실행 블록 - 실행할 코드를 작성한다.

```java
리턴타입 메소드이름 ( 매개변수 선언1, 매개변수 선언2, ... ) {
	// 메소드 실행 블록(실행할 코드)
}
```

<br>

### 리턴문(return) 문

---

> **리턴값이 있는 메서드**
> 
> 
> 메서드 선언에서 리턴 타입이 있는 메소드는 반드시 return 문을 사용해서 리턴값을 지정해줘야 한다. 만일 return 문이 없다면 컴파일 에러가 발생하고, return 문이 실행되면 메소드는 값을 즉시 반환하고 종료된다.
>
> 
> return 값에는 리턴 타입, 또는 리턴 타입으로 자동 변환될 수 있는 값들이 있어야 한다. 예) 리턴 타입이 int면 메서드에서는 byte, short, int 의 값이 리턴되어도 상관없다는 뜻이다.
> 

<br>

> **리턴값이 없는 메소드 : void**
> 
> 
> 이 경우에 사용되는 return은 반환값을 전달하기 위한 용도가 아닌, 메소드 실행을 강제 종료시킬 때, 사용된다.
> 

<br>

### 메서드 호출

---

메서드는 클래스 내 & 외부의 호출에 의해 실행된다. 클래스 내부의 다른 메서드에서 호출할 경웨는 단순한 메서드 이름으로 호출하면 되고, 클래스 외부에서 호출할 때는 클래스로부터 객체를 생성한 뒤 참조 변수를 이용하여 메서드를 호출해야 한다.

<br>

**객체 내부에서 호출**

`메서드( 매개값, … );`

이것도 동일하게, 리턴 타입 변수에 할당할 수 있고, 자동 타입 변환이 될 수 있는 값이면 가능하다. int → double로 할당 가능.

<br>

**객체 외부에서 호출**

`클래스 참조변수 = new 클래스( 매개값, … );`

위 참조 변수와 함께 도트(.)를 사용하여 메서드를 호출할 수 있다. 이는 객체 접근 연산자로 객체가 가지고 있는 필드나 메서드에 접근할 때 사용한다.

`참조변수.메서드( 매개값, … );`

<br>

### 메서드 오버로딩

---

클래스 내에 같은 이름의 메서드를 여러 개 선언한느 것을 메서드 오버로딩(overloading)이라고 한다.

<br>

메서드 오버로딩의 조건은,

1. 매개 변수의 타입
2. 매개 변수의 개수
3. 매개 변수의 순서

위 네개이다.

<br>

주의할 점은 위 세개가 같고 리턴 타입만 다른 경우이다. 이때 JVM은 오버로딩 되어 있는 어떤 메서드를 선택해야 하는지 아직 모르기에 컴파일 에러가 발생한다.

```java
int divide(int x, int y) { ... }
double divide(int moonX, int moonY) { ... }
// 리턴 타입만 다른 경우.
```

<br>

## 인스턴스 멤버 & 정적 멤버

---

클래스로부터 객체(인스턴스)는 하나가 아니라 여러개가 만들어질 수 있다. 이때, 객체마다 필드값이 달라야 한다면 해당 필드는 객체마다 가지고 있는 것이 맞지만, 객체의 필드 값이 모두 같아야 한다면 이 필드를 객체마다 가지고 있을 필요는 없다. 이러한 경우를 위해 클래스 멤버를 **인스턴스 멤버**와 **정적 멤버**로 구분해서 선언할 수 있다.

<br>

### 인스턴스 멤버
---

**객체마다 고유하게 가지고 있는 멤버**

<br>

객체(인스턴스)를 생성한 후, 사용할 수 있는 필드와 메소드들을 말한다. 이를 인스턴스 필드, 인스턴스 메소드라고 부른다. 이 인스턴스 필드와 인스턴스 메소드는 객체에 소속된 멤버이기에 객체 없이는 사용할 수 없다.

<br>

**인스턴스 멤버 선언**

일반적으로 변수, 메서드를 선언하듯이 선언하면 된다. 항상 객체를 생성한 후, 도트(.) 연산자를 통해서만 접근할 수 있다.

<br>

하지만, 인스턴스 메서드는 객체에 소속된 멤버이지만, 객체 내부에 저장되는 것이 아니라 메서드 영역에 저장되고 공유된다. 이는 메서드가 코드 블록이기 때문이다. 즉, 객체마다 동일한 코드 블록을 가지고 있을 필요가 없다.

<br>

그렇다면, 인스턴스라는 용어가 붙은 이유는 ?

메모리 블록 내부에 인스턴스 필드가 사용되는 경우가 있기 때문이다. 인스턴스 필드가 사용되면 메서드도 객체 없이는 실행할 수 없다.

**this**

객체 외부에서 인스턴스 멤버에 접근하기 위해 참조 변수를 사용하는 것과 마찬가지로 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있다. 객체는 자신을 this라고 표현한다. 보통 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하기 위해서 사용된다.

<br>

### 정적 멤버

---

**클래스에 위치하고 객체들이 공유하는 멤버**

<br>

정적(static) 은 ‘고정된’ 이라는 뜻이다. 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메서드를 말한다. 이는 정적 필드, 정적 메서드라고 부른다.

<br>

**정적 멤버 선언**

static 키워드를 추가로 붙이면 된다.

```java
public class 클래스 {

	// 정적 필드
	static 타입 필드; // 초기화도 가능

	// 정적 메서드
	static 리턴 타입 메서드 ( 매개변수 선언, ... ) { ... }
}
```

위 정적 필드와 정적 메서드는 클래스에 고정된 멤버이므로, 클래스 로더가 클래스(바이트 코드)를 로딩해서 메서드 메모리 영역에 적재할 때, 클래스 별로 관리된다. 따라서 클래스 로딩이 끝나는 대로 바로 사용할 수 있다.

<br>

결국, 객체마다 가지고 있어야 할 데이터라면 (개인정보) **인스턴스 필드**로 선언하고, 객체마다 가지고 있을 필요가 없는 공용 데이터라면 (전체 인구수) **정적  필드**로 선언하는 것이 좋다.

<br>

메서드의 경우에는 인스턴스 필드를 포함하고 있다면 **인스턴스 메서드**로 선언하고, 인스턴스 필드를 포함하고 있지 않다면 **정적 메서드**로 선언한다.

<br>

**정적 멤버 사용**

클래스가 메모리로 로딩되면 정적 멤버를 바로 사용할 수 있다.

```java
public class Calculator {
	static double pi = 3.14159;
}
```

위 클래스를 호출하기 위해서는 아래처럼 [클래스이름][.(도트)][정적 필드명] 을 해주면된다.

<br>

```java
double result1 = 10 * 10 * Calculator.pi;
```

물론 객체 생성후, 해당 객체 참조 변수로 접근할 수 있지만, 정적 요소는 클래스 이름으로 접근하는 것이 좋다.

<br>

위 pi 변수를 대문자로 쓰지 않은 이유(상수가 아닌 이유)

상수란 불변이란 뜻이며, 하나만 존재하고 절대 변하지 않는 값을 말한다. 하지만 위의 경우 하나만 존재하긴 하지만, static 제어자만 붙었으므로 외부에서 접근하여 값을 변경할 수도 있기에 상수가 아니다. 따라서 PI대신 pi를 사용했다. 만일 제어자가 static final 이였다면 pi는 PI로 쓰는게 적절했을 것이다.

<br>

**정적 메서드 선언에서 주의할 점**

객체가 없어도 실행되는 정적 메서드 내부에 인스턴스 필드나, 인스턴스 메서드가 있는 경우 오류가 발생한다. 또한, 어떤 객체에 속해 있는 것이 아니기 때문에, 객체 자신 참조인 this 키워드도 사용 불가능하다.

<br>

그렇다 해도 꼭 정적 메서드에서 인스턴스 멤버를 사용하고 싶다면, 정적 메서드 내부에서 인스턴스를 생성한 후, 이 참조 변수를 통해 접근해야 한다(main() 함수도 이 정적 메서드에 포함됨).

<br>

### 싱글톤 (Singleton)

---

```java
public class 클래스 {

	// 정적 필드
	private static 클래스 singleton = new 클래스();

	// 생성자
	private 클래스() { }

	// 정적 메서드
	static 클래스 getInstance() {
		return singleton;
	}
}
```

1. 필드에서 자기 자신의 객체를 생성한 후, private으로 외부에서 접근을 막음.
2. 외부에서 new 생성자를 통해 새로운 객체 생성을 막기 위해 생성자 선언을 private으로 해줌.
3. 외부에 동일한 객체를 전달하기 위한 getInstance 메서드를 생성하여 만들어둔 객체 참조를 전달.

<br>

똑같은 역할을 하는 어떤 객체를 사용자마다 하나씩 생성하게 되면 자원 낭비가 심할 수 있다. 따라서 객체를 하나만 만들어서 관리하므로써 자원을 아끼고 효율적으로 사용할 수 있게 된다. 

<br>

하지만, 같은 객체를 사용함으로써 서로에 대한 자원의 임계구역이 제대로 지켜지지 않았을 때, 그 파급과 피해는 막심할 수 있다. 금액 조회를 생각해봤을 때, 10만원을 이체했지만, 20만원이 이체되었다고 확인되는 경우 이것은 엄청난 피해가 될 수 있다. 따라서 이를 해결하기 위해 싱글톤 패턴을 이용할 때는 반드시 stateless를 지키는 것이 중요하다. 즉, 필드를 공유하지 못하도록 설계해야 한다. (지역변수를 이용)

<br>

### final 필드 & 상수

---

**final**

‘최종적’이라는 뜻을 가지고 있는 final은 초기 값이 저장되면 이것이 최종적인 값이 되어 프로그램 실행 도중 수정할 수 없다. 

<br>

**final이 붙은 필드를 초기화 하는 방법**

1. 선언부에서 동시에 할당하는 경우.
2. 생성자에서 할당하는 경우

위 두가지 규칙이 지켜지지 않는 경우 오류가 발생한다.

<br>

**상수 (constant)**

일반적으로 불변의 값을 상수(static final)이라고 부른다. 수학의 원주율, 지구의 무게, 지구의 둘레 같은 경우에 해당한다.

<br>

final을 상수라고 부르지는 않는다. 그 이유는 불변의 값은 객체마다 저장할 필요가 없는 공용성을 띄고 있고, 여러가지 값으로 최기화 될 수 없기 때문이다. 상수 값은 모두 대문자로 작성하는 것이 관례이다. 또한, 서로 다른 언어가 혼합되는 경우 스네이크 케이스(snake_case) 기법을 사용하여 단어 중간에 _(언더바)를 이용한다.

<br>

## 패키지와 접근 제한자

---

자바에서는 클래스를 체계적으로 관리하기 위해 **패키지(package)** 를 사용한다.

<br>

패키지의 물리적인 형태는 파일 시스템의 폴더이다. 패키지는 단순히 파일 시스템의 폴더 기능만 하는 것이 아니라 클래스의 일부분으로, **클래스를 유일**하게 만들어주는 **식별자 역할**을 합니다. 클래스 이름이 동일하더라도 **패키지가 다르면 다른 클래스로 인식**한다. 클래스의 전체 이름은 ‘패키지 이름 + 클래스 이름’ 인데 패키지가 상, 하위로 구분되어 있다면 도트(.)를 사용하여 다음과 같이 표현한다.

`상위패키지.하위패키지.클래스`

<br>

### 패키지 선언

---

클래스를 작성할 때, 해당 클래스가 어떤 패키지에 속할 것인지를 선언하는 것을 패키지 선언이라고 한다.

<br>

```java
package 상위패키지.하위패키지;

public class ClassName { ... }
```

위에서 ClassName은 상위패키지.하위패키지 경로에 있는 클래스이다. 같은 클래스 이름이더라도 패키지 경로가 다르다면, 다른 클래스로 인식한다.

<br>

패키지 이름

- 숫자로 시작하면 안된다. 특수문자는 ‘’$, ’-’ 만 가능하다.
- java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용해서는 안된다.
- 모두 소문자로 작성하는 것이 관례이다.

<br>

**Tip**

> 회사들 간에 패키지가 서로 중복되지 않도록 보통 회사의 도메인 이름으로 패키지를 만든다. 도메인은 등록 기관에서 유일한 이름으로 검증된 이름이기에 도메인 이름으로 패키지 이름을 만든다. 또한, 도메인 이름의 역순으로 이름을 지어주어 포괄적인 이름이 상위 패키지가 되지 않도록 설계하고, 마지막은 프로젝트 이름을 붙여주는 것이 관례이다.
> 
> 
> ```java
> package org.space.haram
> ```

<br>

**import 문**

사용하고자 하는 클래스 또는 인터페이스가 다른 패키지에 소속되어 있다면, import 문을 사용하여 해당 패키지의 클래스 또는 인터페이스를 가져와 사용할 것임을 컴파일러에게 알려줘야 한다.

<br>

```java
import 상위패키지.하위패키지.클래스이름;
import 상위패키지.하위패키지.*;
```

<br>

import 문의 작성 위치는 패키지 선언과 클래스 선언 사이이다. *는 해당 패키지에 소속된 클래스들을 모두 사용하겠다는 의미이다. import 문은 개수에 제한이 없고 얼마든지 추가해도 된다. 주의할 점은 상위 패키지를 import 했더라도 하위 패키지까지는 import가 되는 것은 아니다.

<br>

예외가 있다. 서로 다른 패키지에 동일한 클래스 이름이 존재하고, 두 패키지가 모두 import 되었다면, 컴파일러는 어떤 패키지의 클래스를 사용해야 할 지 모르기에, 이럴 때는 패키지가 포함된 클래스 전체 이름을 코드에 기술해야 한다.

<br>

```java
package org.hankook;

public class Tire() { ... }
```

```java
package org.kumho;

public class Tire() { ... }
```

위 서로 다른 패키지에 같은 이름을 가진 클래스가 존재한다고 가정한다.

<br>

```java
package org.haram;

import org.hankook.*;
import org.kumho.*;

public class Car {
	org.hankook.Tire tire1 = new org.hankook.Tire();
	org.kumho.Tire tire2 = new org.kumho.Tire();
}
```

위처럼 풀 네임을 명시하지 않으면 컴파일러는 어떤 Tire 클래스를 사용해야 할지 모르므로, 전체 이름을 꼭 명시해주어야 한다.

<br>

## 접근 제한자

---

**접근 제한자(Access Modifier)** 는 말 그대로 접근을 제한하기 위해 사용된다. 여기서의 접근은 클래스 및 인터페이스 그리고 이들이 가지고 있는 멤버의 접근을 말한다.

 

- public 접근 제한자 - 외부 클래스가 자유롭게 사용할 수 있다.
- protected 접근 제한자 - 같은 패키지 또는 자식 클래스에서 사용할 수 있다.
- private 접근 제한자 - 외부에서 사용할 수 없다.

<br>

위 세가지 접근 제한자를 적용하지 않았을 때, default 접근 제한을 가진다

- default 접근 제한 - 같은 패키지에 속한 클래스만 사용할 수 있다.

<br>

private > default > protected > public 

왼쪽으로 갈 수록 접근하기 힘들다는 뜻이다.

<br>

### 클래스의 접근 제한

---

**default 접근 제한**

클래스를 선언할 때, public을 생략했다면, 클래스는 default 접근 제한을 가진다. 클래스가 default 접근 제한을 가지면, 패키지에서는 아무런 제한 없이 사용할 수 있지만, 다른 패키지에서는 사용할 수 없도록 제한된다.

<br>

**public 접근 제한**

클래스가 public 접근 제한을 가지면, 같은 패키지뿐만 아니라 다른 패키지에서도 아무런 제한 없이 사용할 수 있다. 클래스를 다른 개발자가 사용할 수 있도록 라이브러리 클래스로 개발할 때는 public 접근 제한을 갖도록 해야 한다.

<br>

### 생성자의 접근 제한

---

객체를 생성하기 위해 new 연산자로 생성자를 호출한다. 생성자가 어떤 접근 권한을 갖느냐에 따라 호출 가능 여부가 정해진다.

<br>

**public 접근 제한**

public 접근 제한은 모든 패키지에서 아무런 제한 없이 생성자를 호출할 수 있다.

<br>

**protected 접근 제한**

default 접근 제한과 마찬가지로 같은 패키지에 속하는 클래스에서 생성자를 호출할 수 있도록 한다. 차이점으로 다른 패키지에 속한 클래스가 해당 클래스의 자식(child) 클래스라면 생성자를 호출할 수 있다.

<br>

**default 접근 제한**

같은 패키지에서 아무런 제한 없이 생성자를 호출할 수 있으나, 다른 패키지에서는 생성자를 호출할 수 없도록 한다.

<br>

**private 접근 제한**

동일한 패키지이건, 다른 패키지이건 상관없이 생성자를 호출하지 못하도록 제한한다. 오직 클래스 내부에서만 생성자를 호출할 수 있고 객체를 만들 수 있다.(싱글톤 패턴에서 주로 쓰이는 생성자 접근 제한)

<br>

### 필드와 메소드의 접근 제한

---

**public 접근 제한**

모든 패키지에서 아무런 제한 없이 필드와 메소드를 사용할 수 있도록 한다.

<br>

**protected 접근 제한**

default 접근 제한과 마찬가지로 같은 패키지에 속하는 클래스에서 필드와 메서드를 호출할 수 있도록 한다. 차이점으로 다른 패키지에 속한 클래스가 해당 클래스의 자식(child) 클래스라면 필드와 메서드를 호출할 수 있다.

<br>

**default 접근 제한**

필드와 메서드를 선언할 때 접근 제한자를 생략하면 default 접근 제한을 가진다. 이는 같은 패키지에서는 아무런 제한 없이 필드와 메서드를 사용할 수 있지만, 다른 패키지에서는 필드와 메서드를 사용할 수 없다.

<br>

**private 접근 제한**

오로지 클래스 내부에서만 필드와 메서드를 사용할 수 있다.

<br>

### Getter와 Setter 메서드

---

보통 객체 지향 프로그래밍에서는 객체의 필드를 객체 외부에서 직접적으로 접근하는 것을 막는다. 그 이유는 외부에서 마음대로 변경할 경우에 객체의 무결성이 깨질 수 있기 때문이다.(비정상적인 접근을 막기 위함)

<br>

이런 문제점을 해결하기 위해 객체 지향 프로그래밍에서는 메서드를 통해서 필드 값을 변경할 수 있고, 필드 값을 얻을 수 있도록 설계한다. 이는 메서드에서 값이 유효한지 판단한 후에 필드 값을 저장할 수 있도록 안전장치를 만들 수 있기 때문이다.

<br>

따라서 필드값을 변경할 수 있도록 제공하는 메서드를 Setter, 필드값을 외부로 전달할 수 있는 메서드를 Getter라고 한다. 즉, 필드 값은 외부에서 접근하지 못하는 private로 접근 제한을 설정하고, Getter와 Setter는 public 외부에서 접근할 수 있도록 public 접근 제한으로 설정하여 필드값을 안전하게 변경/사용 하는 것이 중요하다.

<br>

만일 필드 값이 boolean 타입이라면 Getter 메서드의 이름을 get으로 시작하지 않고 is로 시작하는 것이 관례이다.