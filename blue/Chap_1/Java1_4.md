# 1-4 산술 연산

자바는 C 언어에 기반을 둔 언어로 다음 표와 같이 익숙한 연산자를 사용한다.

a++ , ++a

| 연산자 | 결합 방향 |
| --- | --- |
| [] , . , () (메서드호출) | 왼쪽 |
| ! , ~ , ++ , — , +(단항) , -(단항) , () , (캐스트) new | 오른쪽 |
| * , / , % (나머지) | 왼쪽 |
| + , - | 왼쪽 |
| << , >> , >>>(산술시프트) | 왼쪽 |
| < , > , <= , >= , instanceof | 왼쪽 |
| == , != | 왼쪽 |
| &(비트곱) | 왼쪽 |
| ^(배타적 비트합) | 왼쪽 |
| | (비트합) | 왼쪽 |
| &&(논리곱) | 왼쪽 |
| || (논리합) | 왼쪽 |
| ?: ( 조건부) | 왼쪽 |
| = , += , -= , *= , /= , %= , <<= , >>= , >>>= , &= , ^= , |= | 오른쪽 |
<br>

### 1.4.1 할당

```jsx
/ = 연산자는 할당 연산자
x = expression;

// 다음 두 식은 같은 결과를 낸다.
amount -= 10;
amount = amount - 10;
```
<br>

### 1.4.2 기본 계산

- 사칙 연산은 +, -, *,  / 로 나타낸다. ⇒ 정수의 경우 나눗셈 하면 정수로 인식해 17/5 ⇒ 3 이 된다. ( 주의 )
- % 연산자는 나머지를 돌려주는 연산자인데 흔히 정수가 짝수인지 검사 할 때 사용한다.
- 증감 연산자가 있다
    
    ```jsx
    n--; // n에 1을 뺀다
    n++; // n 에 1을 더한다
    
    String arg = arg[n++]; // 예전 방식
    ```
    
- **note**
    - 자바가 공언한 목표 중 하나는 이식성이다.
        
        ⇒ 이식성 이란 어떤 가상 머신에서도 계산 결과가 같아야 한다.
        
    - 계산 과정에서 발생하는 오버플로 위험을 줄이고, 부동 소수점 정밀도를 높이기 위해 최신 프로세서는 64비트 보다 큰 부동 소수점 레지스터를 사용한다.
    - 자바는 위와 같은 최적화를 선호한다. 그렇지 않으면 부동 소수점 연산이 느려지고, 덜 정확할 수 있기 때문이다.
    - 이 문제를 신경쓰는 소수 사용자를 고려하여 strictfp라는 제어자를 제공한다.
        
        ⇒ 메서드에 strictfp 제어자를 추가하면 해당 메서드의 모든 부동 소수점 연산은 전체 플랫폼에서 같은 결과를 반환한다. 결국 이식성이 높아진다.
        
<br>

### 1.4.3 수학 메서드

- 자바는 숫자를 제곱수로 만드는 연산자가 없다.
    
    ⇒ 그래서 Math.pow 메서드를 호출해야 한다.
    

```jsx
Math.pow(x, y); // x^y 를 반환
Math.sqrt(x); // x의 제곱근을 반환
```

- 위 메서드들은 정적(static) 메서드이므로 객체(인스턴스)로 호출 불가능하다.
- **static** 상수와 마찬가지로 메서드가 선언된 클래스 이름을 메서드 앞에 붙여야 한다.
- Math 클래스에는 최댓값과 최솟값을 계산하는 `Math.min` , **`Math.max`** 메서드, 삼각함수와 로그 함수를 위한 메서드, `Math.PI` , `Math.E` 와 같은 메서드도 존재한다.
- **note**
    - Math 클래스에는 정수를 더 안전하게 계산하는 여러 메서드 존재
    - 3( 1000000000 * 3 )은 -1294967296 으로 계산된다. 이것은 수학 연산자가 계산이 오버플로 되었을때 일어나는 현상이다.
        
        ⇒ int 형의 최대 값인 2억을 넘는 값이기 때문에 발생
        
    - 위 문제를 해소하기 위해 `Math.multiplyExact( 100000000, 3 )` 을 호출한다.
        
        ⇒ 결과는 틀린 결과를 반환하지 않고 예외 처리가 발생하거나 프로그램 종료 가능하다.
        
    - `addExact` , `subtracExact` , `incrementExact` , `decrementExact` , `negateExact` 메서드가 더 있고, 모두 int 와 long 매개 변수 버전을 제공한다.
    - 몇 가지 수학 메서드는 다른 클래스에 들어있다.
        
        Ex) Integer , Long 클래스에는 부호없는 값을 다루는 `compareUnsigned` , `divideUnsigned` , `remainderUnsigned` 존재
        
    - 덜 효율적이라도 언제나 결과가 동일한 부동 소수점 계산을 원한다면 앞에서 설명한 것을 사용하면 된다(1.4.2장)
        
        ⇒ 수학 메서드를 엄격하게 구현한 **StricMath** 클래스
        
<br>

### 1.4.4 숫자 타입 변환

- 연산자에 사용한 피연산자의 숫자 타입이 다르면 숫자를 공통 타입으로 변환한 후 결합한다. 순서는 다음과 같다
    1. 피연산자 중 하나가 double 타입이면 다른 하나를 double로 변환
    2. 피연산자 중 하나가 float 타입이면 다른 하나를 float로 변환
    3. 피연산자 중 하나가 long 타입이면 다른 하나를 long으로 변환
    4. 이외에는 두 피연산자를 int 로 변환
- 자바에서는 정보 손실이 없다면 언제나 합법적인 변환으로 간주한다.
    - byte 에서 short, int, long, double 로 변환
    - short 에서 int, long, double 로 변환
    - int 에서 long, double 로 변환
    
    ⇒ 예외적으로 합법적인 변환이지만 정보를 잃을 수 있는 경우가 있다.
    
    - int 에서 float으로 변환
    - long 에서 float, double로 변환
        
        ⇒ `float f = 123456789;`
        
        float의 유효 자릿수가 약 일곱 개 이므로 실제로 f 는 1.234567892E8 이 된다.
        
- 합법적인 변환을 제외하고 강제 변환을 수행할 때는 캐스트 연산자를 사용해야 한다.
    
    `double x = 3.75;`
    
    `int n = (int) x;`
    
    이렇게 작성하면 소수부는 버리고 n을 3으로 설정한다.
    
- 타입 변환 대신 가장 가까운 정수로 반올림하고 싶을 때는 Math.round 메서드를 사용하는데 반환 값은 long 타입 값이다.
    
    `int n = (int) Math.round(x); // 답이 int범위 안에 들어간다는 사실을 알고 있을 때 호출 방법`
    
    여기서 x 는 3.75 이므로 n은 4가 된다. 정수 타입을 바이트 수가 더 적은 정수 타입으로 변환할 때도 캐스트를 사용해야 한다.
    
    `int n = 1;`
    
    `char next = (char)(’J + n); // 75를 ‘K’로 변환 한다.`
    
    아래와 같이 더 작은 정수 타입으로 캐스트 하면 하위 바이트들만 보존된다. 
    
    `int n = (int) 3000000000L; // n 을 -1294967296으로 설정한다.`
    
    - note
        
        Math.toIntExact 메서드는 long을 int로 변환할수 없을 때 예외를 일으킴.
        
        캐스트로 주요 숫자 부분이 사라질 위험이 있을 때 사용

<br>  

### 1.4.5 관계 연산자와 논리 연산자

- ==, != 연산자는 동등성을 검사한다.
- boolean 타입 표현식은 && ( 논리곱 ), || ( 논리합 ), ! ( 논리 부정 ) 연산자와 결합 가능
    
    ⇒  0 <= n && n < length 는 n 이 0 (포함) 과 length (미포함) 사이에 있으면 true
    
- 단락평가는 첫 번째 조건이 false면 두 번째 조건 평가하지 않는다.
    
    ⇒ 두 번재 조건이 오류를 일으킬 가능성이 있을 때 유용함
    
    `n != 0 && s + (100 - s) / n < 50; // 오류 발생 안함` 
    
- 조건 연산자 : 피 연산자 세개인 연산자로 조건이 true 일 경우 첫 번째 값이 결과가 됨, false일 경우 두 번째 값이 결과가 됨.
    
    `time < 12 ? “am” : “pm”`
    
- note
    - 논리 연산자와 관련 있는 비트단위 연산자에는 &(and 비트곱), | (or 비트합), ^ (xor 배타적 비트합) 이 있다. 비트단위 연산자는 정수의 비트 패턴에 작용한다.
    - 시프트 연산자의 오른쪽 인수는 왼쪽 인수가 int 이면 32로 나눈 나머지, long 이면 64로 나눈 나머지가 된다. 1 << 35 는 1 << 3, 결과는 8

<br>

### 1.4.6 큰 숫자

기본 정수 타입이나 부동 소수점 타입의 정밀도로 충분하지 않을 때 java.math 패키지의 BigInteger 와 BigDecimal 클래스를 사용하면 된다. 이 클래스들의 객체는 임의 길이로 연속된 수를 나타낸다.

 ⇒ BigInteger : 정밀도 정수 연산을 구현

 ⇒ BigDecimal : 부동소수점 수에 동일 동작을 구현

 ⇒ valueOf 는 long을 BigInteger로 변환